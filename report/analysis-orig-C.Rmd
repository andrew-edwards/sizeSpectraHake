---
title: "Analyses of hake lengths using size spectra approach -- original data, just strata C"
author: "Andrew Edwards"
output: pdf_document
fontsize: 12pt
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  fig.width = 10,
  fig.height = 8
)
```

```{r, packages}
library(dplyr)
library(sizeSpectra)    # Probably need latest version
library(pacea)
# load_all()  # maybe best to do manually.
```

KEEP may need to do these:

- check plots with .html version - all good execept 2021 histogram
    - have got working but it's still slightly different
- then can delete loop non-functionalised version here.
- Tidy this up then should be able to just repeat functions for Strata C and
  other strata.

- relook at this, maybe make appendices for each option (or separate files).
- functionalise the `MLEbins_res` part
- look into data carefully, for example 2008 all strata has some very low
`prop_measured`,
- aha: late on see lookatme chunk `tt <- filter(raw_simp_prop_new, year == 2008, strata %in%
  strata_to_keep)` then `filter(tt, prop_measured < 0.01) %>% as.data.frame()`;
  clear that they're all NC, and see the plot (final set here), clear bumps at
  30mm, 40mm, and 50mm. Dubious, prob remove NC (such coarseness would be too
  much - ooh, though MLEbins could cope with it, agh fiddly though).

-  Maybe even try all strata separately? Might not be enough data
though. Separate files may be best - easier to compare.
- HERE NEXT - do a data wrangling file then separate analysis ones (since can
  just use functions probably).
- think might have same issue as Amy's problem -should we really scale up. Can
  sometimes be extreme.

## Load wrangled data

This is what should be changed for each analysis.

```{r load}
raw_simp_prop <- readRDS("raw_simp_prop_orig.rds")
this_analysis <- "orig_C"    # what to append to filenames for anything we're
                             # saving, else keep object names the same here
strata_to_analyse <- "C"
# strata_to_analyse <- c("C", "NC", "S", "SC", "N")    # equals strata_to_keep;
                                                       # may want to do more individually
# Automatically get right start year, may need tweaking.
ifelse(strata_to_analyse == "C",
  min_year_to_analyse = 1994,
  min_year_to_analyse = 2001)      # data look okay but Iain had said 2004 for
                                   # all strata, so check TODO
```

## Do analysis

HERE  NEXT - put argument in `fit_all_years()` for min year and max year, and
use `min_year_to_analyse` and then filter in the function.

TODO `fit_all_years` should automatically take into account years based on
strata choice. Maybe not though as should make it explicit each time.
```{r fitallyearsfunction}
res_all_years <- fit_all_years(raw_simp_prop,
                               strata = strata_to_keep,
                               bin_width_each_year = bin_width_each_year)
# plot(res_all_years, par.cex = 0.8,) in next chunk but not echoed

```

\clearpage

```{r, plotall, fig.pos = 'p', fig.height = 6.9, echo=FALSE}
plot(res_all_years,
     par.cex = 0.8,)    # For ISD plot
```

Caption for ISD plot:

The y-axis is (a) linear and (b) logarithmic. For each bin, the horizontal green
line shows the range of body lengths of that bin, with its value
on the y-axis corresponding to the total number of individuals in bins whose
minima are $\geq$ the bin's minimum. By definition, this includes all individual
in that bin; for example, all $n$ individuals are $\geq$ the minimum of
the first (left-most) bin, so that bin is at $n$ on the y-axis. The vertical
span of each grey rectangle shows the possible numbers of
individuals with body length $\geq$ the
body length of individuals in that bin (horizontal
span is the same as for the green lines). The maximum number of such individuals
is the same as the green line, and the minimum number (bottom of grey rectangle)
is the total number of individuals $\geq$ the bin's maximum. By definition, this is then the
green line for the next bin. This plotting method allows us to properly represent the
discrete binned data on a continuous scale.
The text
in (a) gives the MLE for the length size-spectrum exponent
$b$, and the sample size $n$.

```{r caption}
caption_index <- 1   # index to use for detailed captions

```
TODO (adapting from MEPS vignette; double check the numbers): For example, the first bin is for lengths
between `r res_all_strata[[caption_index]]$counts_per_bin_desc$binMin[1]` and `r res_all_strata[[caption_index]]$counts_per_bin_desc$binMax[1]` mm, and
countains a count of `r f(res_all_strata[[caption_index]]$counts_per_bin_desc$binCount[1])` individuals. We don't know
how those individual's lengths are distributed within the bin. The green line on
the y-axis illustrates that the number of individuals $\geq$ the minimum of the
bin (`r res_all_strata[[caption_index]]$counts_per_bin_desc$binMin[1]` mm) is
`r f(sum(res_all_strata[[caption_index]]$counts_per_bin_desc$binCount), 1)`, namely
all the individuals because this is the minimum length in the data. The grey
shaded area shows the uncertainty -- the number (on the y-axis) of possible individual individuals with
body mass $\geq$ any x-value within the bin is between
`r f(sum(res_all_strata[[caption_index]]$counts_per_bin_desc$binCount) - res_all_strata[[caption_index]]$counts_per_bin_desc$binCount[1], 1)`
and
`r f(sum(res_all_strata[[caption_index]]$counts_per_bin_desc$binCount), 1)`
(all individuals in the bin could be the smallest
length within the bin or the highest).


For 2004: Clearly that final right-hand value looks like an outlier, and it is just for
one fish:
```{r outlier}
tail(res_all_strata[[caption_index]]$counts_per_bin_desc)
```
We could go back and try removing, but that's a little arbitrary for now.

So $b$ is the length size-spectrum exponent, $b_l$. To convert to weight
exponent, $b_w$, for a length-weight exponent of $\beta$ (writing up derivation elsewhere):

$b_w = (b_l + 1) / \beta - 1$

or, going the other way,

$b_l = \beta (b_w + 1) - 1$

For example, for first year we have, assuming $\beta = 3.1802$ for now:
```{r, bweight}
b_weight <- b_l_to_b_w(res_all_years[[1]]$b_l)
b_weight
```

Make a tibble of all results and mutate it on:

```{r saveallres}
# Save all results in MLEbin_res_all_years
# TODO make a function
MLEbin_res_all_years <- tibble::tibble(
                                  year = unlist(lapply(res_all_years, '[[',
                                                       "year")),
                                  xmin = unlist(lapply(res_all_years, '[[',
                                                       "xmin")),
                                  xmax = unlist(lapply(res_all_years, '[[',
                                                       "xmax")),
                                  n = unlist(lapply(res_all_years, '[[', "n")),
                                  b_l = unlist(lapply(res_all_years, '[[',
                                                      "b_l")),
                                  b_l_confMin = unlist(lapply(res_all_years,
                                                              '[[',
                                                              "b_l_confMin")),
                                  b_l_confMax = unlist(lapply(res_all_years,
                                                              '[[',
                                                              "b_l_confMax"))) %>%
  mutate(b_w = b_l_to_b_w(b_l),
         b_w_confMin = b_l_to_b_w(b_l_confMin),
         b_w_confMax = b_l_to_b_w(b_l_confMax))
  # if want standard errors:
  # b_l_stdErr = (abs(b_l_confMin - b_l) + abs(b_l_confMax - b_l))/(2*1.96)
```

TODO 2021 figures, dig into data, looks like scaling up of counts happened for a
few sampled fish in one poorly-sampled haul?

## Go through ISD plots to decide which years should be excluded

So go through the ISD plots, taking into account sample size `n`. Comments on
each year (with exclude if warranted, else include):  TODO these might be strata
C only - think should do each strata separately and combine sensible ones 2014
looks way different for all regions combined. TODO

2004 - could remove single big value, but need justification, include

2005 - n = 16, exclude

2006 - n = 24, exclude

2007 - does have the hump of larger sizes

2008 - slight hump of larger sizes

2009 - good fit

2010 - slightly weird fit, with one somewhat larger size

2011 - great fit, very slight hump of larger sizes

2012 - good fit though strange gap before large set of sizes

2013 - pretty good fit

2014 - slightly unusual fit, with a bit of a hump

2015 - goodish fit, with 'missing' larger sizes

2016 - very nice fit, $n$ almost 50,000

2017 - good fit, with one somewhat larger size

2018 - good fit, with 'missing' larger sizes

2019 - weird fit because only four bins, because mode is so high - strange one,
exclude (but look into more?)

2020 - $n=10$ so exclude (explains the large confidence intervals in the plot
with it included)

2021 - kind of funny, though need to redo without bins TODO. Looks like a small
sample may have got scaled up a lot?

This suggests
excluding analyses for years:
```{r excludeyears}
years_exclude <- c(2005, 2006, 2019, 2020)
```

## Show the plot for all years

Now plot the estimated hake recruitments of age-0's for each year against the
corresponding $b_l$, and add the uncertainties.

```{r, plotrecruitments}
plot_b_recruitment(MLEbin_res_all_years)
```

TODO notes may not be for this actual plot.
So, what does this mean. Large recruitment years ($> 20\%$ of the 2010
recruitment) always seem to have a higher $b_l$. Note that 2021 has a long tail
of uncertainty (reaching quite high), but that's because it will have only been
observed in one year of commercial data.

A high $b_l$ seems necessary for high recruitment, but is not sufficient. Kind
of makes sense -- other things can happen during further life-history stages.

But, a low $b_l$ seems to imply low recruitment. This could be a heads up for
advice.

Of course, this may well all fall apart with further analyses, validation, and more
data.

In terms of the assessment done at the start of 2023, we have to assume recruitment
for recruitment in 2022 (which hasn't been observed in data in
the assessment model, but is what we can calculate $b_l$ for, hopefully in a
timely fashion) and 2023 (which are just being spawned while we are doing the
2023 assessment). The assumption is based on the stock recruitment curve with a
large uncertainty, and is shown in blue on the next plot.

## Results for new data from December 2023

Not looked at in detail yet HERE. Need switches for strata and years.

HERE Might not be strata C. Do each choice as a separate file.
2014 for C should only have a few at 70. `filter(raw_simp_prop, year == 2014,
strata == "C", x == 70)` only has two lines as shown here:

First just strata C:

```{r fitallyearsfunctionnew}
res_all_years_new <- fit_all_years(raw_simp_prop_new,
                                   strata = "C", #strata_to_keep,
                                   bin_width_each_year = bin_width_each_year_new)
# plot(res_all_years_new, par.cex = 0.8,) in next chunk but not echoed

# HERE something wrong, as this clearly has lots in 70 in 2014:
res_all_years_new[[21]]$year
# res_all_years_new[[21]]$counts_per_bin %>% as.data.frame()
res_all_years_new[[21]]$counts_per_bin %>% filter(binMid == 70)
# HERE it's not using just strata C for some reason
# but
filter(raw_simp_prop_new, year == 2014, strata == "C", x == 70) %>% a()
```

\clearpage

```{r, plotallnew, fig.pos = 'p', fig.height = 6.9, echo=FALSE}
plot(res_all_years_new,
     par.cex = 0.8,)    # For ISD plot
```

TODO make this a function:

```{r saveallresnew}
# Save all results in MLEbin_res_all_years
# TODO make a function
MLEbin_res_all_years_new <- tibble::tibble(
                                  year = unlist(lapply(res_all_years_new, '[[',
                                                       "year")),
                                  xmin = unlist(lapply(res_all_years_new, '[[',
                                                       "xmin")),
                                  xmax = unlist(lapply(res_all_years_new, '[[',
                                                       "xmax")),
                                  n = unlist(lapply(res_all_years_new, '[[', "n")),
                                  b_l = unlist(lapply(res_all_years_new, '[[',
                                                      "b_l")),
                                  b_l_confMin = unlist(lapply(res_all_years_new,
                                                              '[[',
                                                              "b_l_confMin")),
                                  b_l_confMax = unlist(lapply(res_all_years_new,
                                                              '[[',
                                                              "b_l_confMax"))) %>%
  mutate(b_w = b_l_to_b_w(b_l),
         b_w_confMin = b_l_to_b_w(b_l_confMin),
         b_w_confMax = b_l_to_b_w(b_l_confMax))
  # if want standard errors:
  # b_l_stdErr = (abs(b_l_confMin - b_l) + abs(b_l_confMax - b_l))/(2*1.96)

years_exclude_new <- NULL # c(2005, 2006, 2019, 2020)
```

TODO need to look at figures and work out which years should be excluded.

```{r, plotrecruitmentsnew}
plot_b_recruitment(MLEbin_res_all_years_new,
                   xlim = c(-30, 0))
```

Now all strata from 2001 onwards TODO check, Iain said 2004:

```{r fitallyearsfunctionnewall}
res_all_years_new_all <- fit_all_years(filter(raw_simp_prop_new,
                                              year >= 2001),
                                       strata = strata_to_keep,
                                       bin_width_each_year = bin_width_each_year_new)
# plot(res_all_years_new, par.cex = 0.8,) in next chunk but not echoed
```

\clearpage

```{r, plotallnewall, fig.pos = 'p', fig.height = 6.9, echo=FALSE}
plot(res_all_years_new_all,
     par.cex = 0.8,)    # For ISD plot
```

TODO make this a function TODO annotate C in previous ones

```{r saveallresnewall}
# Save all results in MLEbin_res_all_years
# TODO make a function
MLEbin_res_all_years_new_all <- tibble::tibble(
                                  year = unlist(lapply(res_all_years_new_all, '[[',
                                                       "year")),
                                  xmin = unlist(lapply(res_all_years_new_all, '[[',
                                                       "xmin")),
                                  xmax = unlist(lapply(res_all_years_new_all, '[[',
                                                       "xmax")),
                                  n = unlist(lapply(res_all_years_new_all, '[[', "n")),
                                  b_l = unlist(lapply(res_all_years_new_all, '[[',
                                                      "b_l")),
                                  b_l_confMin = unlist(lapply(res_all_years_new_all,
                                                              '[[',
                                                              "b_l_confMin")),
                                  b_l_confMax = unlist(lapply(res_all_years_new_all,
                                                              '[[',
                                                              "b_l_confMax"))) %>%
  mutate(b_w = b_l_to_b_w(b_l),
         b_w_confMin = b_l_to_b_w(b_l_confMin),
         b_w_confMax = b_l_to_b_w(b_l_confMax))
  # if want standard errors:
  # b_l_stdErr = (abs(b_l_confMin - b_l) + abs(b_l_confMax - b_l))/(2*1.96)

years_exclude_new_all <- c(2020, 2021, 2022, 2023)  # Had these earlier, not looked in detail yet: c(2005, 2006, 2019, 2020)
```

TODO need to look at figures and work out which years should be excluded.

```{r, plotrecruitmentsnewall}
plot_b_recruitment(MLEbin_res_all_years_new_all,
                   years_exclude = years_exclude_new_all)
#                   xlim = c(-30, 0))
```

HERE
```{r lookatme}
only_2008 <- filter(raw_simp_prop_new,
                    year == 2008,
                    strata %in% strata_to_keep)
filter(only_2008, prop_measured < 0.01) %>% as.data.frame()

only_2014 <- filter(raw_simp_prop_new,
                    year == 2014,
                    strata %in% strata_to_keep)
summary(only_2014)
filter(only_2014, prop_measured < 0.01) %>% as.data.frame()  # none
filter(only_2014, prop_measured < 0.05) %>% as.data.frame()  #

filter(only_2014, x == 70) %>% as.data.frame()   # TODO something coarser also,
                                        # these are lots of SC - so again with
                                        # the coarse measurements. Aha - those
                                        # 70 measurements (the max) should be
                                        # spread out.
filter(only_2014, x == 69) %>% as.data.frame()   # only 5
filter(only_2014, x == 71) %>% as.data.frame()   # only 4
```

## Moving $b_l$ vs. $b_w$ figures to here.

```{r blbwrelationship}
# par(mfrow=c(2,1))

b_l_vec <- seq(-10, 0, 0.1)

plot(b_l_vec,
     b_l_to_b_w(b_l_vec),
     xlab = "b_l",
     ylab = "b_w",
     ylim = range(b_l_vec))

b_w_vec = seq(-4, 0, 0.1)

plot(b_w_vec,
     b_w_to_b_l(b_w_vec),
     xlab = "b_w",
     ylab = "b_l",
     xlim = range(b_w_to_b_l(b_w_vec)))
```

So those are pretty straight, suggesting indeed a linear relationship. Can
calculate derivative analytically. TODO in other .tex write up.

```{r exit, eval=FALSE, echo=FALSE}
knitr::knit_exit()
```
